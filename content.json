[{"title":"how-to-get-a-new-job","date":"2019-10-21T03:06:16.000Z","path":"2019/10/21/how-to-get-a-new-job/","text":"现在的我做了一份不错的工作，但尴尬的是我并不是特别适合现在这份工作，也不是特别喜欢这个方向，我想换工作，但是我很迷茫。 疑问 对于招聘者而言，他们需要什么样的人？（能干活，比别的面试者优秀，是一个抢手的/好的员工） 我的时间非常有限，约定的找工作的倒计时一天天地减少，但是感觉自己要学的却很多。我该如何取舍？ 不知道现在市场如何？经济寒冬下，招人的企业有哪些？如何对症下药，成为符合企业口味的人？ 解答 数据来源","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"http://yoursite.com/tags/essay/"}]},{"title":"career-survival-guide","date":"2019-10-21T03:04:21.000Z","path":"2019/10/21/career-survival-guide/","text":"《职场生存指南》 定期与领导沟通 定期向领导汇报 让领导看到我的劳动成果","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"http://yoursite.com/tags/essay/"}]},{"title":"programmer-reflection-book","date":"2019-10-21T03:02:36.000Z","path":"2019/10/21/programmer-reflection-book/","text":"《程序员反思录》 当得了程序员，就得耐得住没有头发的寂寞。 做一行爱一行，既然从事了这个行业，就要专注于这个行业。（虽然我不是科班出身，但我也知道这个行业最核心最根本的东西是什么，不管新技术如何发展，数学、数据结构、操作系统、计算机网络、汇编原理……这些都是需要我去持续学习的。） 不积跬步无以至千里，质变总是来源于量变。（一天学一小时数学，哪怕一周学一小时数学，一个月就有4个小时，一年就有48个小时，十年就有480个小时了。） 不要两耳不闻窗外事，一心只搞代码。没有了业务，代码便失去了其价值，所以理解业务也是很重要的。 学习经济学、投资学、心理学，关心历史、文学，看电影，听音乐。","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"http://yoursite.com/tags/essay/"}]},{"title":"20180716-essay","date":"2019-10-21T02:44:07.000Z","path":"2019/10/21/20180716-essay/","text":"第一篇博客 - 关于编程语言的一些思考 我是一名SAP技术顾问，SAP相关系统的二次开发工程师，但是我不想从事这一个行业。我希望成为一个Go服务端开发工程师。 从今天起，我会每天记录一些东西，以勉励自己。 但是我突然发现了一个问题，我为什么要学习Go语言呢？我花费了时间去研究语言，真的有意义吗？ 每个语言都有其所擅长的领域，去年我跟自己说，想要在数据科学这个领域去发展，但是一年过去了，在这个领域上面，我毫无进展。除了这个领域，在服务器端、游戏等方向，我也想过要往这些方向去发展，但是方向越多，则越容易乱。 我应该选择方向，而不是选择语言。 首先，我得明确自己的需求。我需要尽快地换一份工作，而这份工作也不能是一份随随便便的工作，它必须是让我在自己的职业生涯上发展得越来越好，能走得越来越远的。现在有那么多个领域：AI、数据科学、VR/AR、无人驾驶……但这么多的领域其实都是基于机器学习的，也就是算法的工作才是未来的方向。而语言，应该是排在算法之后的。至于学习哪一门语言更容易找得到工作，我想JAVA应当是首选了吧，配合现在所学的ABAP语言，要找一个甲方公司难度不大，且要往SAP相关领域去发展也有一定的优势。而Go语言虽然在服务端有一定的优势，但毕竟还是一个新生语言，总还是没那么成熟的，它在区块链、Docker都有一定的优势，且实验楼也将其作为后台语言，所以前景也还是有的。【但是如果学得不够深，那作用就不大了，或者说做 后端开发的，自身没有一点JAVA基础和C++基础，总还是有点问题的吧】而Python作为一个当前火爆的语言，将其掌握应该是必须的吧。但是语言归语言，还是不能偏离中心，方向才是主体。 其次，我得考虑自身的实际情况。我真正开始接触这个行业（学科）的东西，应该启蒙于实验楼吧，也就是大三的下学期，到现在也才短短的一年多一点的时间。虽然对这个行业的资讯了解得也不少，但是自身的基础是远远不足的，不管是底层的基础知识，还是数据结构与算法，抑或是网络的知识，都只能说是一知半解，没有一个系统的知识库。而且说到计算机语言，我也不能说有哪一门语言是算得上掌握的程度的，这是个赤裸裸的现实。如果我花了时间，没有达到企业的要求，那我失业的概率就非常大了。 最后，还要考虑到一个问题。中国是属于劳动力过剩的国家，所以软件行业在中国是很容易遭遇中年危机的，不像在国外，程序员可以工作到四五十岁也没什么问题。企业可以通过标准化、框架等等，让软件实施变得简单，所以即使找新人也可以将老员工替代掉，从而节省成本。所以这是个赤裸裸的问题，必须要从长远地去考虑。而要长远地考虑，不外乎几个选择： 考研，越往高处，可取代性就越小； 管理能力，综合能力越强，可取代性越小； 小众，如现在的AI、区块链，小众而具有前景的技术栈，短期可取代性更小； 一个方向（正确的方向）一直走，做到无人可取代的地步 综上所述，坚持学Go语言没有问题，但是要把基础打好，为了就业，必须把JAVA和ABAP学好。为了不被中年危机淘汰，必须加强自己的管理能力和英语能力。而方向要选定一个，物联网或区块链或数据科学方向，但是不管哪一个方向，前提都是打好基础，将数学能力和算法能力提升上来。 自我点评： 有一定的论据，但是缺乏说服力，缺少数据的支持。 说得比较笼统，没有一个很具体的解决方案。 要做的事情那么多，但时间却如此有限，如何分清先后顺序呢？","categories":[],"tags":[{"name":"private, essay","slug":"private-essay","permalink":"http://yoursite.com/tags/private-essay/"}]},{"title":"20190604-essay","date":"2019-10-21T02:35:53.000Z","path":"2019/10/21/20190604-essay/","text":"距离找工作的Deadline还有63天，距离2019年还有4天，距离《楼+之数据分析与挖掘实战》的结束还有26天，距离年终考核还有13天… 2018年经济下行，众多企业上演下岗潮，尤其互联网企业。此时的环境，找工作特别困难，拉勾网中，看到找工作的都说Python找工作特别难。现在留给我的，还有什么选择呢？ 翻阅着求职APP的岗位，发现适合自己的岗位真的没有多少，除了自己本行的职位。关键是，我对自己行业的把握，也并没有太多。 我时常会想起我堂叔说的，工作只是为了赚钱养活自己和家人，工作并不一定就要是自己喜欢做的事情。 虽然我从大四就开始接触python，但是却没有坚持下来，直到现在我的python水平也还是半桶水。而且我已经错过了python找工作的最佳时期，现在的python确实到了一种红海的时期——会的人（入门）太多，提供的岗位太少。而各大公众号，甚至CSDN都在开Python班，更不用说一些老字号的培训班了。僧多粥少，我这种进去竞争，即使简历造假也只能是去送了。 其实现在的我，已经没有太多奢求，能有一份工作让我不出差，便是解我燃眉之急的良药了。当然，如果有得选，我更希望是符合自己的职业发展预期的。 目前的我，没有那么多时间给我纠结和犹豫了。以下列出我可选之项吧： 【通过数据分析/手动爬取各大求职网站，广东地区ABAP/Java/Python/Go的招聘要求，进行整理可视化】 做回本行：ABAP a. 认真应对考核，做多点文档，包括UI5和HANA的，想办法应用到项目上。 b. 把基础复习一遍，《小黄书》、《进阶》、《周正军》的博客、《汪子熙》的博客、Ink网上的ABAP教程【尽量将简历填充满些，ABAP/HANA/UI5/C4C/CP】 c. 英语基础（听说能力、读写能力）,练口语之余，尽可能用英文撰写文档 d. 拓展学习：Java、数据结构、网络等 e. 未来的发展：BI/WEB/HANA/Leonardo 追逐梦：Python/Go a. 将实验楼的课程刷完，再慢慢拓展技术栈 追逐梦2: 考验 a. 将计算机基础与数学基础打牢，通过考研初试 b. 想办法让导师看到我的能力，争取通过复试 c. 研究生学习人工智能/大数据/数据分析与挖掘方向的知识 疑问： a. 我究竟是要做“研究型”还是”工程型“的人？ b. 我是走技术管理还是走技术专家的方向？ c. 需要考什么证书？需要什么能力？","categories":[],"tags":[{"name":"private, essay","slug":"private-essay","permalink":"http://yoursite.com/tags/private-essay/"}]},{"title":"how-to-jump-out-of-comfortzone","date":"2019-10-21T02:33:16.000Z","path":"2019/10/21/how-to-jump-out-of-comfortzone/","text":"《如何跳出舒适圈》– 长更 导论 为什么程序员会有中年危机？为什么工作几年后就很难有上升的空间？如何在不同的技术栈中转换，如何找到不同技术栈的共通点？成长的过程中，应该以什么为主？什么为辅？ 现象分析具体情况具体分析，通过案例分析为何程序员会遭遇35岁的中年危机？为何会被年轻人取代？为何十多年的工作经验能被甚至一两年的工作经验取代？ 自身问题？（技术落伍，没有与时俱进？拿了很高的工资却没有为企业创造相应的价值？） 企业问题？（同样能解决问题，优先选择成本更低的？） 社会问题？（连小学生都开始学习编程了？掌握编程不再是你唯一的长处？那你跟别的会编程的人相比，你的优势在于什么？除了编程，你还会什么？） 拓展思考（你懂业务吗？懂企业管理吗？团队的管理呢？） 解决方案1. 基础知识 DataStructure &amp; Algorithm（数据结构与算法） Mathmetics（数学） Computer Language（编程语言） DataBase（数据库） Computer Network（计算机网络） Computer Operator（计算机操作系统） Extends（拓展能力） 2. 软技能（情商/EQ） 团队管理能力 沟通能力 协作能力 时间管理能力 3. 理财能力（财商/FQ） 投资学 经济学 社会学 心理学","categories":[],"tags":[{"name":"private","slug":"private","permalink":"http://yoursite.com/tags/private/"}]},{"title":"SAP 常用表","date":"2019-09-09T15:21:00.000Z","path":"2019/09/09/SAP常用表/","text":"SAP 各模块常用表…… 核心模块FI 表名 描述 t001 ska1 skb1 bkpf bseg bsik bsak bsid bsad kna1 knb1 lfa1 lfb1 CRMBT(Business Transaction) 表名 描述 CRMD_ORDERADM_H 单据抬头 CRMD_ORDERADM_I 单据明细 DD07T 域值的下拉列表描述 CRM_JEST 单据状态 TJ30T 用户状态&amp;参数文件&amp;状态的描述 CRMC_PROC_TYPE 单据类型与状态参数文件的对应关系 CRMC_PROC_TYPE_T 单据类型的描述 CRMC_OBJECTS_GEN AET增强对象的表&amp;对象名&amp;自生成表结构 CRMD_BRELVONAE 单据的前后序关系 BP(Business Partner) 表名 描述 BUT000 客户主数据 BUT050 客户的关系 BUT100 客户的角色 TBZ9A 关系的描述 TB001 BU_GROUP及其描述 ADR2 电话 ADCP 职能/部门 USR21 用户所在表 Installation based 表名 描述 IBIB IBIN IBST CRMD_MPK_READING 安装点 - 计数器 Others 表名 描述 STXL 长文本相关 STXH TTXID TTXIT axt_run_fielddef AET字段及其数据元素 参考链接： https://wiki.scn.sap.com/wiki/display/CRM/SAP+CRM+Some+more+tables http://www.tcodesearch.com/sap-tables/search?q=bp+change+history Marketing 表名 描述 CUAND_CE_IC_ROOT CUAND_CE_IA_RT CUAND_CE_IC_FCET","categories":[],"tags":[{"name":"sap","slug":"sap","permalink":"http://yoursite.com/tags/sap/"}]},{"title":"Financial Knowledge","date":"2019-09-06T05:47:00.000Z","path":"2019/09/06/Financial-Knowledge/","text":"Financial knowledge…… 资讯获取渠道专业名词流动比率商业世界中，资金周转尤为重要，企业多是透过供应商的赊货，银行的短期贷款，才能持续其运营。 一旦资金周转不灵，尤其是加息周期开始，不仅不能对这些债权人准时还款，还会失去各方的信用，面临清盘的危机。 投资者应该如何分析企业周转不灵的问题呢？ → 如何通过流动比率观察出企业的变现能力？ 流动比率 = 流动资产 ÷ 流动负债 简单来说，流动比率越高，代表企业状况越健康。 流动资产是指在一年内很容易变现的资产，包括存货、应收账款、有价证券、现金。 流动负债代表一年内要偿还的债务，如短期借款、应付票据等。 此比率（流动比率）用于计算短期可运用的资金和必须清偿债务的比例，分析企业的短期偿债能力。 当流动比率 &gt; 1:1： $1的债务背后有多于$1的资产支持，也就是说如果所有债权人同时进行追讨，企业仍有足够的偿付能力 当流动比率 &lt; 1:1： $1的债务背后没有充足的资产偿还债务，当债务到期，企业就会有资不抵债的压力，便需变卖固定资产或进一步筹集资本 但是，流动比率并不一定越高越好的。 过高的流动比率可能是因为存货过多，应收账款无法收回。当这两个账目占流动资产比重特别高时，背后原因可能是滞销或者坏帐，皆是周转不灵的先兆。 作为投资者，一般选择流动比率高的企业。但另一方面，如果过高则可能代表着变现能力问题。 那么我们可以用什么准则来判断比率呢？ 答案：与同行比较。若高于同行基准，代表企业在同业中财政较为健康；若以倍数高于基准的话，则应仔细进一步分析流动资产，找出哪个部分出现问题。 总而言之，流动比率让投资者概括地了解企业的财务状况，亦可跟其他同业比较，了解其相对优势。若发现比率过高，便要在账目细节上研究，可能是企业的运营出现问题，需多加小心。","categories":[],"tags":[{"name":"Financial","slug":"Financial","permalink":"http://yoursite.com/tags/Financial/"}]},{"title":"Python3-string-handling","date":"2019-08-15T08:37:18.000Z","path":"2019/08/15/Python3-string-handling/","text":"Python 字符串操作的demo 1. 字符串拼接 方法一：使用逗号或者加号进行拼接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788\"\"\" 注意，逗号拼接会额外带有一个空格。 \"\"\" #codea = 'are'b = 'you'c = 'ok'print(a, b, c)print(a + b +c)#outputare you okareyouok\"\"\" 逗号拼接数字会以字符串的形式连接，而加号拼接数字就不再是拼接了，而是代表加法 \"\"\"#codea = 12b = 4567print(a, b)print(a + b)#output12 45674579\"\"\" 加号无法拼接不同类型的变量，该问题同上，虽然+运算符具有拼接字符串的作用，但是在拼接字符串和数字时，会被认为是运算符加号。 \"\"\"#codea = 'abc'b = 123print(a, b)print(a + b)#outputabc 123Traceback (most recent call last): File \"test2.py\", line 7, in &lt;module&gt; print(a + b)TypeError: must be str, not int\"\"\" 使用加号拼接str和unicode会有UnicodeDecodeError。 \"\"\"# 该问题仅在python2中会遇到，因为python2当中的string编码为ascii，若要使用Unicode，需要在字符串前面加一个u。而到了python3中，所有的字符串编码都默认是Unicode了。#codea = '中文'b = u'中文'print a, bprint a + b#output中文 中文Traceback (most recent call last): File \"test.py\", line 7, in &lt;module&gt; print a + bUnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) # Python3中的Unicode类型打印type转变为了str类型，这就解释了上面的那个问题。# Python3#codenum = 123str1 = 'abc'str2 = '中文'str3 = u'中文'print(type(num))print(type(str1))print(type(str2))print(type(str3))#output&lt;class 'int'&gt;&lt;class 'str'&gt;&lt;class 'str'&gt;&lt;class 'str'&gt;# Python2#codenum = 123str1 = 'abc'str2 = '中文'str3 = u'中文'print type(num)print type(str1)print type(str2)print type(str3)#output&lt;type 'int'&gt;&lt;type 'str'&gt;&lt;type 'str'&gt;&lt;type 'unicode'&gt; Python 编码为什么那么蛋疼？ ⚠️ 当我们使用加号(+)操作符去连接大量的字符串的时候是非常低效率的，因为加号连接会引起内存复制以及垃圾回收操作。像这种代码，是非常不可取的： 123s = ''for p in parts: s += p 这种写法会比join()方法运行的慢一些，因为每一次执行+=操作的时候会创建一个新的字符串对象。最好是先收集所有的字符串片段然后再把它们连接起来。 方法二：直接拼接 123456# 该方法只能用于字符串的拼接，不能用于变量拼接#codeprint('abc''xyz')#outputadcxyz 方法三：使用%或者format进行拼接 1234567891011# 该方法借鉴于C语言的printf函数，多个变量是倾向于使用这种方法，因为它的可读性更强。#codea = 'x'b = 'y'c = 'z'print('abc%s' % a)print('abc&#123;0&#125;&#123;1&#125;&#123;2&#125;'.format(a, b, c))#outputabcxabcxyz 方法四：使用字符串函数join拼接 1234567891011# 该方法多用于列表，元组，或者较大的字符串拼接操作#codea = 'hello'b = 'world'str1 = [a, b]print(''.join((a, b)))print(''.join(str1))#ouputhelloworldhelloworld 参考链接： https://www.cnblogs.com/yexuesong/p/9232349.html","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python-Module_usecase","date":"2019-08-15T08:07:46.000Z","path":"2019/08/15/Python-Module-usecase/","text":"Python常用模块的用法及demo 1. 基础模块datetime datetime 模块提供了一些类用于操作日期时间及其相关的计算。比较常用三个类型： date 封装了日期操作 datetime 封装日期+时间操作 timedelta 表示一个时间间隔，也就是日期时间的差值 Demo1 :12345678910111213141516171819202122# 日期时间的获取In [1]: from datetime import date, datetime, timedeltaIn [2]: date.today()Out[2]: datetime.date(2018, 12, 7)In [3]: datetime.utcnow()Out[3]: datetime.datetime(2018, 12, 7, 7, 1, 23, 844015)In [4]: t = datetime.now()In [5]: tOut[5]: datetime.datetime(2018, 12, 7, 15, 1, 43, 880715)In [6]: t.dayOut[6]: 7In [7]: t.yearOut[7]: 2018In [8]: t.minuteOut[8]: 1 Demo2 :123456789# datetime 对象与字符串之间的相互转换In [9]: tOut[9]: datetime.datetime(2018, 12, 7, 15, 1, 43, 880715)In [10]: datetime.strftime(t, '%Y-%m-%d %H:%M:%S')Out[10]: '2018-12-07 15:01:43'In [11]: datetime.strptime('2018-12-07 00:00:00', '%Y-%m-%d %H:%M:%S')Out[11]: datetime.datetime(2018, 12, 7, 0, 0) Demo3 :1234567891011# 用 timedelta 表示时间差值，可以精确到微妙In [12]: timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, ...: hours=0, weeks=0)Out[12]: datetime.timedelta(0)# 用 timedelta 对 datetime 进行加减操作In [13]: tOut[13]: datetime.datetime(2018, 12, 7, 15, 1, 43, 880715)In [14]: t + timedelta(weeks=1, days=-3, hours=3, minutes=-10)Out[14]: datetime.datetime(2018, 12, 11, 17, 51, 43, 880715) os定义 :这个库模块提供了一些接口来获取操作系统的一些信息和使用操作系统功能，主要的用途是获取和处理文件及文件夹属性 常用方法 : os.path.abspath(path) 返回文件的绝对路径 os.path.basename(path) 返回文件名 os.path.dirname(path) 返回文件路径 os.path.isfile(path) 判断路径是否为文件 os.path.isdir(path) 判断路径是否为目录 os.path.exists(path) 判断路径是否存在 os.path.join(path1[, path2[, …]]) 把目录和文件名合成一个路径 Demo1 :123456789101112131415161718192021222324In [1]: import osIn [2]: filename = '/Users/junlinhe/courses.json'In [3]: os.path.abspath(filename)Out[3]: '/Users/junlinhe/courses.json'In [4]: os.path.basename(filename)Out[4]: 'courses.json'In [5]: os.path.dirname(filename)Out[5]: '/Users/junlinhe'In [6]: os.path.isfile(filename)Out[6]: TrueIn [7]: os.path.isdir(filename)Out[7]: FalseIn [8]: os.path.exists(filename)Out[8]: TrueIn [10]: os.path.join('/Users/junlinhe/', 'courses.json')Out[10]: '/Users/junlinhe/courses.json' Demo2 :123456789101112131415In [1]: import osIn [2]: os.getcwd()Out[2]: '/Users/junlinhe/Code'# 生成 n 个字节的随机数，用于加密，比如作为 Flask 的 SECRETE_KEYIn [3]: os.urandom(24)Out[3]: b'r@t\\x96\\x1b\\xb5\\xab\\xb5\\xe5\\xa4\\xd52N\\x8b\\xfa$\\x91:\\xabHs\\xb9\\x9f\\xa8'# 在当前目录创建一个目录In [4]: os.mkdir('web-app')# 在当前目录创建一个 app.py 文件# 此处可能会报错：权限不够In [5]: os.mknod(os.getcwd() + '/app.py') sysUsage : 获取命令行参数Demo1 :1234567import sysprint(\"Program:\", sys.argv[0])print(\"Parameters:\")for i, x in enumerate(sys.argv): if (i == 0): continue print(i, x) pickle定义 :通过一个实例将 Python 的一个字典存入到文件中并读取出来恢复成字典对象。注意写入和读取文件都需要使用 b 二进制模式。 Usage : Demo :123456789101112131415161718# 如果只是想将对象序列化成一个字节流，那可以使用 pickle.dumps(obj)In [1]: import pickleIn [2]: courses = &#123;1: 'Linux', 2: 'Vim', 3: 'Git'&#125;In [3]: with open('./courses.data', 'wb') as file: ...: pickle.dump(courses, file) ...:In [4]: with open('./courses.data', 'rb') as file: ...: new_courses = pickle.load(file) ...:In [5]: new_coursesOut[5]: &#123;1: 'Linux', 2: 'Vim', 3: 'Git'&#125;In [6]: type(new_courses)Out[6]: dict json JSON 序列化后的内容为字符串，文本写入和读取不需要用二进制格式 序列化：dumps反序列化：loads Demo : 1234567891011121314151617In [1]: import jsonIn [2]: courses = &#123;1: 'Linux', 2: 'Vim', 3: 'Git'&#125;In [3]: json.dumps(courses)Out[3]: '&#123;\"1\": \"Linux\", \"2\": \"Vim\", \"3\": \"Git\"&#125;'In [4]: with open('courses.json', 'w') as file: ...: file.write(json.dumps(courses)) ...:In [5]: with open('courses.json', 'r') as file: ...: new_courses = json.loads(file.read()) ...:In [6]: new_coursesOut[6]: &#123;'1': 'Linux', '2': 'Vim', '3': 'Git'&#125; zip定义 ：zip函数 接受任意多个可迭代对象作为参数 ,将对象中对应的元素打包成一个tuple,然后返回一个可迭代的zip对象，这个可迭代对象可以使用循环的方式列出其元素。若多个可迭代对象的长度不一致,则所返回的列表与长度最短的可迭代对象相同. Usage : 用两个列表生成一个zip对象Demo1 :1234567891011121314# 第n次返回每个列表元素的第n-1个元素，每个列表返回的元素组成一个数组&gt;&gt;&gt; a1=[1,2,3]&gt;&gt;&gt; a2=[4,5,6]&gt;&gt;&gt; a3=[7,8,9]&gt;&gt;&gt; a4=[\"a\",\"b\",\"c\",\"d\"]&gt;&gt;&gt; zip1=zip(a1,a2,a3)&gt;&gt;&gt; print(zip1)&lt;zip object at 0x7f5a22651c08&gt;&gt;&gt;&gt; for i in zip1:... print(i)... (1, 4, 7)(2, 5, 8)(3, 6, 9) Demo2 :123456789&gt;&gt;&gt; zip2=zip(a1,a2,a4)&gt;&gt;&gt; print(zip2)&lt;zip object at 0x7f5a22651d48&gt;&gt;&gt;&gt; for j in zip2:... print(j)... (1, 4, 'a')(2, 5, 'b')(3, 6, 'c') Demo3 :12345678910&gt;&gt;&gt; zip3=zip(a4)&gt;&gt;&gt; print(zip3)&lt;zip object at 0x7f5a22651d08&gt;&gt;&gt;&gt; for i in zip3:... print(i)... ('a',)('b',)('c',)('d',) Demo4:12345678910111213141516\"\"\"In [12]: print(*a4)a b c dIn [13]: print(a4)['a', 'b', 'c', 'd']\"\"\"&gt;&gt;&gt; zip4=zip(*a4 *3)&gt;&gt;&gt; &gt;&gt;&gt; print(zip4)&lt;zip object at 0x7f5a22651f08&gt;&gt;&gt;&gt; for j in zip4:... print(j)... ('a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd') 二维矩阵变换(矩阵的行列互换) Demo :123456789101112# ll每个元素的长度相同&gt;&gt;&gt; l1=[[1,2,3],[4,5,6],[7,8,9]]&gt;&gt;&gt; print([[j[i] for j in l1] for i in range(len(l1[0])) ])[[1, 4, 7], [2, 5, 8], [3, 6, 9]]&gt;&gt;&gt; zip(*l1)&lt;zip object at 0x7f5a22651f88&gt;&gt;&gt;&gt; for i in zip(*l1):... print(i)... (1, 4, 7)(2, 5, 8)(3, 6, 9) collectionscollections 模块主要提供了一些特别的容器类 OrderedDict OrderedDict 是一个特殊的字典。字典本质上是一个哈希表，其实现一般是无序的，OrderedDict 能保持元素插入的顺序： OrderedDict 同样能以元素插入的顺序来进行迭代或者序列化 Demo :123456789101112131415161718192021222324252627282930In [1]: from collections import OrderedDictIn [2]: d = OrderedDict()In [3]: d['apple'] = 1In [4]: d['google'] = 2In [5]: d['facebook'] = 3In [6]: d['amazon'] = 4In [7]: dOut[7]: OrderedDict([('apple', 1), ('google', 2), ('facebook', 3), ('amazon', 4)])In [7]: dOut[7]: OrderedDict([('apple', 1), ('google', 2), ('facebook', 3), ('amazon', 4)])In [8]: for key in d: ...: print(key, d[key]) ...:apple 1google 2facebook 3amazon 4In [9]: import jsonIn [10]: json.dumps(d)Out[10]: '&#123;\"apple\": 1, \"google\": 2, \"facebook\": 3, \"amazon\": 4&#125;' namedtuple 使用普通的元组（tuple）存在一个问题，每次用下标去获取元素，可能会不知道你这个下标下的元素到底代表什么。namedtuple 能够用来创建类似于元组的类型，可以用索引来访问数据，能够迭代，也可以通过属性名访问数据。让你能够更方便实用的代码 Demo :123456789101112# 使用命名元组表示坐标系中的点In [11]: from collections import namedtupleIn [12]: Point = namedtuple('Point', ['x', 'y'])In [13]: p = Point(10, 12)In [14]: p.xOut[14]: 10In [15]: p.yOut[15]: 12 Counter Counter 用来统计一个可迭代对象中各个元素出现的次数，以字符串为例： Demo12345678910111213141516171819202122In [19]: c = Counter('https://www.github.com')In [20]: cOut[20]:Counter(&#123;'h': 2, 't': 3, 'p': 1, 's': 1, ':': 1, '/': 2, 'w': 3, '.': 2, 'g': 1, 'i': 1, 'u': 1, 'b': 1, 'c': 1, 'o': 1, 'm': 1&#125;)In [21]: c.most_common(3)Out[21]: [('t', 3), ('w', 3), ('h', 2)] getopt主要用于处理命令行参数 Demo :1234567891011121314151617181920212223242526import getopt, sysdef main(): try: # o后面有冒号表示o要带参数，h、v则不用带参数 opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", \"output=\"]) except getopt.GetoptError as err: # print help information and exit: print(err) # will print something like \"option -a not recognized\" usage() sys.exit(2) output = None verbose = False for o, a in opts: if o == \"-v\": verbose = True elif o in (\"-h\", \"--help\"): usage() sys.exit() elif o in (\"-o\", \"--output\"): output = a else: assert False, \"unhandled option\" # ...if __name__ == \"__main__\": main() configparser主要用于解析配置文件，参考blog Demo :12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;&gt;&gt; import configparser# 通过configparser包的ConfigParser类创建config对象&gt;&gt;&gt; config = configparser.ConfigParser() # 读取config对象包含的所有部分, DEFAULT的配置不会显示&gt;&gt;&gt; config.sections() []# 读去配置文件，并加载到config对象中&gt;&gt;&gt; config.read('example.ini')['example.ini']&gt;&gt;&gt; config.sections()['bitbucket.org', 'topsecret.server.com']# 判断bitbucket.org是否config对象里的一个section，如果是则返回true&gt;&gt;&gt; 'bitbucket.org' in config True&gt;&gt;&gt; 'bytebong.com' in configFalse# 获取bitbucket模块的key为User对应的value&gt;&gt;&gt; config['bitbucket.org']['User'] 'hg'&gt;&gt;&gt; config['DEFAULT']['Compression']'yes'# 将topsecret.server.com部分的数据赋值给字典 topsecret&gt;&gt;&gt; topsecret = config['topsecret.server.com'] &gt;&gt;&gt; topsecret['ForwardX11']'no'&gt;&gt;&gt; topsecret['Port']'50022'# 直接遍历打印bitbucket.org部分的所有key&gt;&gt;&gt; for key in config['bitbucket.org']: print(key) ...usercompressionlevelserveraliveintervalcompressionforwardx11# 直接读取bitbucket模块的key为ForwardX11对应的value&gt;&gt;&gt; config['bitbucket.org']['ForwardX11'] 'yes' 2.网络相关requests在 requests 库出现之前，网络请求通常用标准库中的 urllib。requests 出现之后，它俨然已经成了 Python 事实上的网络请求标准库 ⚠️ requests库不是标准库的，所以要通过包管理工具导入。1pip3 install requests Demo :123456789101112&gt;&gt;&gt; r = requests.get('https://www.shiyanlou.com')&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers['content-type']'text/html; charset=utf-8'&gt;&gt;&gt; r.text'\\n&lt;!DOCTYPE html&gt;\\n&lt;html lang=\"zh-CN\"&gt;\\n...'# json() 会将返回的JSON数据转化成一个Python字典&gt;&gt;&gt; r = requests.get('https://api.github.com')&gt;&gt;&gt; r.json()&#123;'current_user_url': 'https://api.github.com/user', ...&#125; 3.编码base64 base64 是一种编码方式，它可以将二进制数据编码 64 个可打印的 ASCII 字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 【编码规则】如：010101|01 1010|1010 11|000011 -&gt; 00010101 00011010 00101011 00000011 Demo :1234567In [1]: import base64In [2]: base64.b64encode(b'Hello, world!')Out[2]: b'SGVsbG8sIHdvcmxkIQ=='In [3]: base64.b64decode(b'SGVsbG8sIHdvcmxkIQ==')Out[3]: b'Hello, world!' 4.数据分析相关lxml【待整理-楼+数据分析第一周_网页数据解析与采集】 bs4BeautifulSoup","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python基础笔记","date":"2019-08-15T07:42:57.000Z","path":"2019/08/15/Python-basis-knowledge/","text":"前言：以下链接能找到的知识，本文中不再重复，本文只对描述得不够详尽的内容进行补充或扩展。 Python3官方文档 廖雪峰Python3教程 菜鸟教程 1. 环境搭建略 2. 基础2.1 变量和数据类型 关键字 False def if raise None del import return True elif in try and else is while as except lambda with assert finally nonlocal yield break for not class from or continue global pass 将精度高的浮点数转换成精度低的浮点数： round()内置方法 a. round()如果只有一个数作为参数，不指定位数的时候，返回的是一个整数，而且是最靠近的整数（这点上类似四舍五入） b. 但是当出现.5的时候，两边的距离都一样，round()取靠近的偶数 c. 当指定取舍的小数点位数的时候，一般情况也是使用四舍五入的规则，但是碰到.5的这样情况，如果要取舍的位数前的小树是奇数，则直接舍弃，如果偶数这向上取舍 1234567891011121314&gt;&gt;&gt; round(1.5)2&gt;&gt;&gt; round(2.675)3&gt;&gt;&gt; round(2.675, 2)2.67&gt;&gt;&gt; round(2.635, 2)2.63&gt;&gt;&gt; round(2.645, 2)2.65&gt;&gt;&gt; round(2.655, 2)2.65&gt;&gt;&gt; round(2.665, 2)2.67 使用格式化 123456789&gt;&gt;&gt; a = (\"%.2f\" % 2.635)&gt;&gt;&gt; a'2.63'&gt;&gt;&gt; a = (\"%.2f\" % 2.645)&gt;&gt;&gt; a'2.65'&gt;&gt;&gt; a = int(2.5)&gt;&gt;&gt; a2","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Knowledge Warehouse","date":"2019-08-10T05:21:14.000Z","path":"2019/08/10/Knowledge-Warehouse/","text":"书单、在线学习资源等…… 在线学习资源coding Github StackOverflow CSDN 实验楼 FreeCodeCamp codecademy Udacity Coursera edX 中国大学MOOC 微软-第9频道 微软-magazine 思科-网络课程 慕课网 W3Schools w3school中文版 GeeksforGeeks TutorialsPoint HackerRank Codebeautify https://dzone.com/（ 提供技术新闻、编程教程、及各种工具、开发者的博客等。） http://www.programcreek.com/ https://gitlab.com/ https://www.ibm.com/developerworks/learn/java/index.html（ IBM的JAVA开发者网站，很多干货。） http://www.javaworld.com/ http://www.onjava.com/ http://www.oracle.com/technetwork/java/index.html http://www.weixianmanbu.com/ （讲黑客技术的博客） CodeBinder 金老师的自学网站 MIT-EE公开课 一些在线培训网站 小象学院 极客学院 传智播客 黑马程序员 游戏学编程 Codecombat Codingame 基础篇数学 概率论、线性代数、高等数学、数学分析、高等代数、离散数学、复变函数 极客时间app - 程序员的数学基础课 麻省理工公开课 麻省理工公开课 单变量微积分 + 习题课 麻省理工公开课 多变量微积分 + 习题课 麻省理工公开课 线性代数 + 习题课 麻省理工公开课 概率论 麻省理工公开课 算法导论 麻省理工大学公开课 微积分重点 麻省理工公开课 线性代数重点 统计学 《深入浅出统计学》 《鲜活的数据》 《深入浅出数据分析》 《啤酒与尿布》 《数据之美》 《数学之美》 英语单词 扇贝单词 Merriam-Webster Dictionary（韦氏词典） 牛津高阶词典（OALD） 必应搜索单词看图片 听力 听力（SSS、VOA Special/Standard、） 计算机导论 《编程导论》 《计算机科学概论（第11版）》 《计算机伦理与专业责任》 哈佛大学公开课：计算机科学导论 哈佛大学公开课-计算机科学cs50 麻省理工学院公开课：计算机科学及编程导论 计算机科学速成课(视频) 公开课-编程范式 知乎live - 金老师的计算机基础课 网易云课堂-计算机专业课程体系 计算机组成原理 Book 《计算机组成原理》—唐朔飞 《Computer Organization &amp; Design: A Hardware/Software Interface》—David、 A.Patterson、John.L.Hennessy. 《Digital Design and Computer Architecture》 —David Harris、Sarah Harris 《隐匿在计算机背后的0和1》 《编码的奥秘》 《编译原理》 数电&amp;模电 数据结构与算法 Book 圣经 《The Art of Computer Programming》（共四章） Fundamental Algorithms Seminumerical Algorithms Sorting and Searching Combinational Algorithms 《算法导论》 《算法(英文版·第四版)》（Robert Sedgewick） 入门 《大话数据结构》 严慧敏《数据结构》 《枕边算法书》（林柏睿/崔盛一 译） 《算法图解》（Aditya Bhargava/袁国忠 译） 《挑战程序设计竞赛2：算法和数据结构》（渡部有隆/支鹏浩 译） 基础 《数据结构与算法经典问题解析》 《数学之美 （第二版）》 《编程之美》 《算法之美：隐匿在数据结构背后的原理：C++版》（左飞） 《elementary-algorithms》&lt;英-中&gt; 《算法新解》(刘新宇) 《算法竞赛_经典入门》 《Data structures using C = 数据结构&nbsp;：C语言版》 《数据结构C语言版》 《垃圾回收的算法与实现》（中村成洋等/丁灵 译）、《Algorithms (by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani)》 Website Leetcode 中文版 - 领扣) Leetcode题解 GitHub - elementary-algorithms 极客时间 - 数据结构与算法之美 图灵学院website - 数据结构课 MOOC - 浙大数据结构课 浙大数据结构课-配套习题 实验楼 - 经典算法解题实战 实验楼 - 数据结构(新版) 计算机操作系统Summary 《深入理解计算机系统 / Computer System: A Programmer’s Approach》 《深入理解操作系统》（搭配CMU课程使用） 实验楼 -《操作系统原理与实践》 《编译原理》（搭配轮子哥的博客） 《单片机》 Linux Book 《Unix环境高级编程》 《UNIX编程艺术》 《深入理解LINUX内核》 《UNIX编程艺术》 《The Design of the UNIX Operating System》 《鸟哥私房菜：基础篇》 《鸟哥私房菜：服务器》 鸟哥的Linux私房菜-Online 实验楼 -《Linux基础入门》 实验楼 -《Vim编辑器》 Windows Book 《Windows核心编程 / Windows via C/C++》 《Windows核心编程》 《深入解析Windows操作系统》 计算机网络 Book 《TCP/IP协议详解》 《图解HTTP》 《计算机网络技术》（教材） 《深入理解计算机网络》 王达著 《自顶向下学TCP》 Website 实验楼 -《TCP/IP网络协议基础》 实验楼 - 网络实战项目 MOOC-计算机网络概论 软件工程 《软件工程导论》马广慧 设计模式 《大话设计模式》 《设计模式：复用面向对象》 《Head First设计模式》 代码质量 《编程珠玑 / Programming Pearls》 《重构 / Refactoring》 / Martin Fowler 《代码大全 / Code Complete 2》（第2版） The Mythical Man-Month（Essays on Software Engineering）（人月神话）《人月神话:注释版》 (美) Frederick P. Brooks, Jr.著《软件测试.第2版》 朱少民编著《软件测试实践教程》 兰景英编著《重构 改善既有代码的设计》 马丁·福勒《代码质量》 《代码整洁之道 / Clean Code》 《设计模式 / Design Patterns》 《Implementation Patterns》 《软件设计重构》 《计算机程序的构造和解释 / The Structure and Interpretation of Computer Programs》 《代码优化：有效使用内存》 《Compilers （龙书）》 《Computer Architecture: A Quantitative Approach》 软件测试 《软件测试》 工具篇Git 猴子都能看懂的Git教程 实验楼-《GitHub快速上手实战》 实验楼 - 《Git实战教程》 极客时间 - 完全学会Git、GitHub、Git Server的24堂课 Markdown 官方文档 印象笔记markdown语法 数据库Overview 《数据库系统概念》 《数据仓库经典教程》 MySQL W3School 实验楼 - MySQL基础课程 廖雪峰-SQL教程 《MySQL必知必会》 MongoDB 实验楼 - MongoDB基础教程 Redis 实验楼 - Redis基础教程 编辑器/IDEVisual Studio Code 官方文档 极客时间app - VSCode的使用 Visual Studio Code入门教程（Go） &amp;&amp; Visual Studio入门教程（C++） Cloud Studio 菜鸟教程 Microsoft OfficeExcel 秋叶Excel课程 PPT 秋叶PPT课程 Word 百度 编程语言HTML &amp; CSS 实验楼-HTML基础入门 实验楼-HTML5基础入门 实验楼-CSS速成教程 实验楼-Bootstrap3.0入门 FreeCodeCamp W3school 菜鸟教程 JavaScript JavaScript在线电子书 实验楼-JavaScript基础教程 廖雪峰 JavaScript教程 实验楼训练营 - 《实验网易云音乐》 Node.js 菜鸟教程 官方文档 实验楼 Python基础 绘制Python学习路线思维导图 实验楼 Python3简明教程 第一弹：超全Python学习资源整理（入门系列） 第二弹：超全Python学习资源整理（进阶系列） 廖雪峰python3教程 菜鸟python3教程 FreeCodeCamp Codecomy book - 《Learn Python the hard way》 book - 《简明Python教程》(A Byte of Python) book - 《Python核心编程》 book - 《Python源码剖析》 book - 《流畅的Python》 book - 《500 Lines and Less》（Github项目） 进阶 实验楼 - NumPy 使用教程 实验楼 - NumPy 百题大冲关 实验楼 - Pandas 使用教程 实验楼 - Pandas 百题大冲关 实验楼 - Flask Web 框架 实验楼 - Django基础教程 SQLAlchemy - 官方文档 Jinjia2基础-官方文档 Flask基础-官方文档 项目 Python楼+之Python实战 Python训练营-实现Up work网 A Complete Beginner’s Guide to Django【学习该Django课程，将项目部署到GitHub，记录笔记，发布一个经过自己总结的项目课】 R 实验楼R教程 R语言官方文档 R语言在线学习指南 《R语言实战（第2版）》 Go基础 无闻Go视频教程全集 bilibili Go基础教程 极客时间 - Go语言从入门到实战 极客时间 - Go语言核心36讲 实验楼-《Go By Example中文版》 Go CN每日要闻 项目 实验楼-《Go实现2048》 实验楼-《Go语言制作 MarkDown 预览器》 Java基础 《Head First Java》 实验楼-Java编程语言 菜鸟教程-Java C&amp;C++ book - 《c++primer》 book - 《谭浩强C++教程》 实验楼 - 《C语言入门教程》 book - 《C++ Primer》 实验楼 - 《C语言制作简单计算器》 C 金老师C#课 Ruby LearnRbythehardway 特定领域篇数据科学入门or科普 《集体智慧编程》 《Machine Learning in Action》 《Building Machine Learning Systems with Python》 《数据挖掘导论》 《Machine Learning for Hackers》 《深入浅出数据分析》 《谁说菜鸟不会数据分析》 《赤裸裸的统计学》 《统计数字会撒谎》 《互联网增值的第一本数据分析手册》—GrowingIO可免费下载 《精通Web Analytics 2.0》 《网站分析实战》 《数据化管理：洞悉零售及电子商务运营》—黄成明 数据分析 Python楼+之数据分析与挖掘实战 Python训练营-数据分析入门与进阶 Pandas 使用教程 Pandas 时间序列数据处理 Pandas 百题大冲关 《SciPy and NumPy》 《Python for Data Analysis》 《Bad Data Handbook》 数据可视化 Python 数据可视化 Matplotlib 及 Seaborn 使用教程 使用 Matplotlib 绘制 2D 和 3D 图形 爬虫 Python 网站信息爬虫 机器学习 Book 《数据科学入门》高蓉译 《机器学习》/周志华 《深度学习》 /Ian, Goodfellow 《Foundations of Machine Learning》 - Mehryar Mohri 《机器学习与应用》-雷明 《The Elements of Statistical Learning》 —对应的中文版：《统计学习基础》 《统计学习方法》 李航 《Machine Learning:An Algorithmic Perspective》 《Pattern Recognition And Machine Learning》 《Bayesian Reasoning and Machine Learning》 《Probabilistic Graphical Models》 《Convex Optimization》 ——Stephen 《决战大数据》—车品觉 《精益数据分析》 《The Wall Street Journal Guide to Information Graphics》—-(华尔街日报) 《Machine Learning》 吴恩达机器学习课程（Coursera） 斯坦福大学公开课 CS229 机器学习 CS231n Convolutional Neural Networks for Visual Recognition CS224n Natural Language Processing with Deep Learning 台湾大学公开课 机器学习基石 机器学习技法 Machine Learning and having it deep and structured Coursera Machine Learning Neural Networks for Machine Learning 『机器学习』入门教程汇总 《TensorFlow实战》 自然语言处理(NLP) 《语言学的邀请》 《Natural Language Processing with Python》 推荐系统 《Introduction to Semi-Supervised》 《Learning to Rank for Information Retrieval》—微软亚院 刘铁岩 《Learning to Rank for Information Retrieval and Natural Language Processing》—微软亚院 李航 《推荐系统实战》 《Graphical Models,Exponential Families,and Variational Inference》 Jordan 《推荐系统实战》项亮《计算广告学》刘鹏 云计算 Mircosoft学习资源 语音识别图像识别区块链 实验楼训练营 - 《以太坊》 游戏开发 《游戏开发原理》 运维 《DevOps和自动化运维》 提高篇职业规划 《软件开发者路线图》 《程序员修炼之道 / The Pragmatic Programmer》 软技能 《程序员自我修养》 《程序员的思维修炼》 《说服》 《高难度谈话》 笔试面试篇 GitHub-Interview-Notebook LeetCode 牛客网 猿圈网 ACM题目 数据结构和算法问题Top 50 编程面试中的链表问题Top 30 基于数组的编程问题Top 30 电面编程问题Top 50 《面试微软前必须要读的10本书》 《金三银四跳槽季，程序员面试必备书单》 book - 《cracking the code interview》 book - 《剑指offer》 book - 《程序员面试宝典》 book - 《程序员面试金典》 book - 《编程之美》 book - 《程序员面试手册》（针对初级程序员） book - 《程序员面试攻略(原书第3版) 》（针对资深程序员） others音乐 耶鲁公开课（聆听音乐） 围棋高效学习方法收藏 搜索神器 搜电子书神器 下载软件用 免费下载电子书网站-allitebooks 免费下载电子书网站-it-ebooks bookzz oreilly-freebook free-programming-book 图灵社区 GitBook wowebook 自醒 项目 ➡️ 学习；（在做项目的时候构建自己的代码仓库并组建技术栈） 构建技术栈；（而不是为学习而学习，要找到其中的乐趣并坚持下去） 技术是不断迭代的，关键是树根要稳，奠基要固。 学完一个new knowledge，学会汇总和变成自己的东西。 ⭐️if (学习）{ 禁止打开QQ微信知乎视频等任何娱乐性东西。} else if (休息) {允许打开娱乐应用} else {随你大小便} ⭐️语言／语法／框架……所有技术层面的东西都不是最重要的，数学／逻辑／设计……等思想层面的东西才是最重要的。【重心不能放在技术上，而要放在数学／逻辑思维的训练上。还有最重要的英语。】 投资理财 Web资源 YouTube频道： 我要做富翁 投资理财入门 公众号： 茶话股经 孟岩 老钱说钱 小白读财经 了解资讯类： 36氪","categories":[],"tags":[{"name":"Booklist","slug":"Booklist","permalink":"http://yoursite.com/tags/Booklist/"}]}]